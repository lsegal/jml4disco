<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Disco - Impact Analysis</title>
 
<link href="../style.css" rel="stylesheet" type="text/css" /></head>
<body>





<div id="main">






<div class="wiki" id="content">

 
  
  
   
   <div class="wikipage">
    <div id="searchable"><h1 id="ImpactAnalysis">Impact Analysis</h1>
<h2 id="Introduction">Introduction</h2>
<p>
This document will cover the changes the JML4 Disco project may bring to the overall JML4 Project. We will consider the risks involved, changes in the overall quality, performance and requirements as well as the consequence to any change proposed. the  The following is a check-list of things to consider when performing our impact analysis.
</p>
<h3 id="ImplicationsoftheProposedChange">Implications of the Proposed Change</h3>
<p>
 
</p>
<ul><li>Identify any existing requirements in the baseline that conflict with the proposed change.
</li><li>Identify any other pending requirement changes that conflict with the proposed change.
</li><li>What are the consequences of not making the change?
</li><li>What are possible adverse side effects or other risks of making the proposed change?
</li><li>Will the proposed change adversely affect performance requirements or other quality attributes?
</li><li>Will the change affect any system component that affects critical properties such as safety and security, or involve a product change that triggers recertification of any kind?
</li><li>Is the proposed change feasible within known technical constraints and current staff skills?
</li><li>Will the proposed change place unacceptable demands on any computer resources required for the development, test, or operating environments?
</li><li>Must any tools be acquired to implement and test the change?
</li><li>How will the proposed change affect the sequence, dependencies, effort, or duration of any tasks currently in the project plan?
</li><li>Will prototyping or other user input be required to verify the proposed change?
</li><li>How much effort that has already been invested in the project will be lost if this change is accepted?
</li><li>Will the proposed change cause an increase in product unit cost, such as by increasing third-party product licensing fees?
</li><li>Will the change affect any marketing, manufacturing, training, or customer support plans?
</li></ul><p>
 
</p>
<h3 id="SystemElementsAffectedbytheProposedChange">System Elements Affected by the Proposed Change</h3>
<p>
 
</p>
<ul><li>Identify any user interface changes, additions, or deletions required.
</li><li>Identify any changes, additions, or deletions required in reports, databases, or data files.
</li><li>Identify the design components that must be created, modified, or deleted.
</li><li>Identify hardware components that must be added, altered, or deleted.
</li><li>Identify the source code files that must be created, modified, or deleted.
</li><li>Identify any changes required in build files.
</li><li>Identify existing unit, integration, system, and acceptance test cases that must be modified or deleted.
</li><li>Estimate the number of new unit, integration, system, and acceptance test cases that will be required.
</li><li>Identify any help screens, user manuals, training materials, or other documentation that must be created or modified.
</li><li>Identify any other systems, applications, libraries, or hardware components affected by the change.
</li><li>Identify any third party software that must be purchased.
</li><li>Identify any impact the proposed change will have on the projectâ€™s software project management plan, software quality assurance plan, software configuration management plan, or other plans.
</li><li>Quantify any effects the proposed change will have on budgets of scarce resources, such as memory, processing power, network bandwidth, real-time schedule.
</li><li>Identify any impact the proposed change will have on fielded systems if the affected component is not 
</li></ul><h2 id="Milestone1">Milestone 1</h2>
<p>
Milestone 1 was dedicated to researching the project to better understand the system as we were not starting from scratch and were going to be building an existing evolving system. 
</p>
<h2 id="Milestone2">Milestone 2</h2>
<p>
In this milestone we began studying the prototype provided to us. The following are some changes the prototype of JML4-Disco had compared to the original JML4 project.
</p>
<ul><li>Class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed</tt> was created.
</li><li>Class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise_timings</tt> was added only for benchmarking and outputting of results.
</li><li>The <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProverStrategyFactory</tt> was modified to include the new distributed prover strategy.
</li><li>Several classes in the Distributed Prototype have had to be altered so they implement <tt>java.io.Serializable</tt>:
</li><li><tt>org.jmlspecs.jml4.esc.gc.lang.KindOfAssertion</tt>
</li><li><tt>org.jmlspecs.jml4.esc.result.lang.Result</tt>
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VC</tt>
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcOperator</tt>
</li><li>Several classes had the 'final' keyword removed from the declaration of instance variables to allow for serialization:
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcLogicalExpression</tt>
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcArithExpression</tt>
</li><li>In class <tt>org.jmlspecs.jml4.esc.Esc</tt> some variables were changed to be 'final' for serialization purposes.
</li><li>Class <tt>org.jmlspecs.jml4.esc.vc.lang.VcArithExpression</tt>, <tt>org.jmlspecs.jml4.esc.vc.lang.VcLogicalExpression</tt> and <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> also had changes made for custom serialization overriding.
</li><li>The instance variable <tt>operator</tt> in class <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> was made public for the purpose of serialization.
</li><li>Outputs and logging were added to class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise</tt> and several method calls are made with null parameters to make serialization possible.
</li><li>In class <tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> instance variables <tt>CompierlerOptions</tt> and <tt>ProblemReporter</tt> are set to null to allow serialization.
</li><li>Several classes derived from <tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> have <tt>problemReporter</tt> set to null to allow serialization.
<ul><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter</tt>
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapter</tt>
</li></ul></li><li>In class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveEntireVC::prove(VcProgram)</tt>, variable <tt>problemReporter</tt> is null to allow serialization. (??)
</li><li>In class <tt>org.jmlspecs.jml4.esc.Esc</tt> several changes were made pertinent to timing and printout. (??)
</li><li>Eclipse-class <tt>org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment</tt> was given an empty constructor to facilitate the creation of serializable classes which inherit from it.
</li><li>Eclipse-class <tt>org.eclipse.jdt.internal.compiler.lookup.LookupEnvironmentEmptyForSerialization</tt> is an "empty class to allow easy serialization." (??)
</li></ul><h2 id="Milestone3">Milestone 3</h2>
<h3 id="ProposedChanges">Proposed Changes</h3>
<p>
In this milestone, we began to improve the distributed component of the project by working on it's load balancing strategy. Our goal was to come up with a second generation prototype. We also began looking at the Boogie component but a more in depth risk analysis for it can be found in milestone 4 when a more concrete design was integrated with the project. 
</p>
<h3 id="ImplicationResults">Implication &amp; Results</h3>
<p>
The following is a list of changes made to accommodate the second prototype of the distributed component of the JML4-Disco project.
</p>
<h3 id="SecondPrototype">Second Prototype</h3>
<ul><li><tt>org.jmlspecs.jml4.compiler.JmlCompilerExtension</tt> was changed. (see svn changelog 102)
</li><li><tt>org.jmlspecs.jml4.compiler.JmlCompilerOptions</tt> had distributed options added to it. (see svn changelog 102)
</li><li><tt>org.jmlspecs.jml4.esc.Esc</tt> was changed for threading. (see svn changelog 102)
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> instance variables CompierlerOptions and ProblemReporter are now transient.
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.cvc3.Cvc3Adapter</tt> a problem is reported every time a failed attempt to invoke cvc3 is made. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter</tt> a problem is reported every time isabelle fails to launch. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.SimplifyAdapter</tt> a problem is reported every time simplify fails to launch.
</li><li>In <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed</tt> the name of the properties configuration file in which URLs are found was changed.
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise</tt> underwent several changes.
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProverStrategyFactory</tt> was modified again.
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VC</tt> underwent several changes for custom serialization.
</li><li>Class <tt>org.jmlspecs.jml4.esc.vc.lang.VcOperator</tt>, <tt>org.jmlspecs.jml4.esc.vc.lang.VcQuantifire</tt> and <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> was changes made for custom serialization overriding.
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcTypeBinding</tt> is a new type to allow serialization.
</li><li>The existing tests in package <tt>org.jmlspecs.eclipse.jdt.core.tests.esc</tt> were copied to <tt>org.jmlspecs.eclipse.jdt.core.tests.esc.distributed</tt> and modified for applicability to distribution.
</li><li><tt>org.eclipse.jdt.core.compiler.org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise.java</tt> commented out 5 lines in the proveVC(...) method in order to prevent adding to and checking the cache.
</li><li><tt>org.eclipse.jdt.core.compiler.org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter.java</tt> Added a check in matchingTheoryFileExists(...) method to ensure that the file is readable before attempting the read.
</li></ul><h2 id="Milestone4">Milestone 4</h2>
<h3 id="ProposedChanges1">Proposed Changes</h3>
<h3 id="ImplicationResults1">Implication &amp; Results</h3>
<h3 id="Boogie">Boogie</h3>
<p>
 
</p>
<h4 id="Impactedexistingelements">Impacted existing elements</h4>
<blockquote>
<table class="wiki">
<tr><td> JmlCompilerExtension.java </td><td> Changes in this file are meant to allow a new proving strategy: "Boogie", along with compiler options to turn it on and off. 
</td></tr><tr><td>JmlCompilerOptions.java </td><td> Changes in this file add a compiler option for EnableJmlBoogie 
</td></tr></table>
</blockquote>
<h4 id="Newelements">New elements</h4>
<blockquote>
<table class="wiki">
<tr><td> <strong>New package</strong> 
</td></tr><tr><td> org.jmlspecs.jml4.boogie 
</td></tr><tr><td>This package contains all pertinent files for proving using boogie. These new elements are based on existing object used for verification through simplify, isabelle and cvc3
</td></tr></table>
</blockquote>
<blockquote>
<table class="wiki">
<tr><td> <strong>Details list of classes added</strong> </td><td> a 
</td></tr><tr><td> Boogie.java </td><td> A compiler extension that enables Java code to be passed through Microsoft Boogie in order to formally verify JML DbC annotations. 
</td></tr><tr><td> BoogieAdapter.java </td><td> Wraps the Boogie runtime into a Java class that can be called from Eclipse's compilation stack. 
</td></tr><tr><td> BoogieSource.java </td><td> Represents a buffer of Boogie source code that will be passed to a Boogie runtime object. 
</td></tr><tr><td> BoogieSourcePoint.java </td><td>  Represents a point in a Boogie source code file. Used to map points in Boogie source back to a Java source file. 
</td></tr><tr><td> BoogieVisitor.java  </td><td> Traverses each node in the AST producing equivalent boogie code.
</td></tr></table>
</blockquote>
<h3 id="Serialization">Serialization</h3>
<h4 id="ChangesElicitation">Changes Elicitation</h4>
<blockquote>
<p>
<strong>The following are the details of the changes needed to improve serialization process:</strong>
</p>
</blockquote>
<p>
 
</p>
<blockquote>
<p>
One of the possible ways of speeding up current VC serialization process is using <strong>Externalizable</strong> interface.  
Externalizable is a subclass of Serializable.  It provides more control to the programmer over what and how the objects are being serialized and it produces smaller serialized object in terms of size.
</p>
</blockquote>
<blockquote>
<p>
The Externalizable interface defines 2 methods: readExternal(ObjectInput in) and writeExternal(ObjectOutput out).  Unlike default serialization, programmers have the full control over what and how to serialize the object instance's variables.  Nevertheless, this also implies the needs of extra codes of dealing with serialization process.
</p>
</blockquote>
<blockquote>
<p>
Our concern in JML4Disco is serializing Vc and all its sub-types objects, therefore the changes required to use externalizable interface are:
</p>
</blockquote>
<ol><li>VC class implements Externalizable interface.
</li><li>VC class and all its subclasses must add 2 new methods: readExternal() and writeExternal().  Note that all subclasses must override the VC's readExternal() and writeExternal methods.
</li><li>All Vc's subclass must explicitly call super.readExternal() and super.writeExternal() in order to serialize parent's attributes.
</li><li>The order of serialization and de-serialization must match properly.  For instance:
<pre class="wiki">    public void readExternal(ObjectInput in) throws IOException,
        ClassNotFoundException {
            super.readExternal(in);
            this.operator = new VcOperator();
            this.operator.readExternal(in);
    }

    public void writeExternal(ObjectOutput out) throws IOException {
            super.writeExternal(out);
            this.operator.writeExternal(out);
    }
</pre></li><li>The VC and its subclass must have a default constructor that takes no argument.
</li><li>All attributes that will be serialized must not be final.
</li><li>Must replace the default ObjectOutput.write() and ObjectInput.read() calls in ProveVcProgram.java, ProveVcDistributed.java with appropriate readExternal(), and writeExternal() methods.
</li><li>The inheritance makes externalization process more complex.  As we expect to receive any type of vc at the server, to deserialize the vc into appropriate type requires serializing that information during the serialization process and uses reflection get the appropriate type and then de-serialize the object.
</li></ol><blockquote>
<p>
Prior serialize the VC object, store the actual type of VC:
</p>
<pre class="wiki">        out.writeUTF(vc.getClass().getName());
        vc.writeExternal(out);
</pre></blockquote>
<blockquote>
<p>
On receiving a serialized object:
</p>
<pre class="wiki">       in = new ObjectInputStream(request.getInputStream());            
       String vcClassName = in.readUTF();
       Class c = Class.forName(vcClassName);
       Object o = c.newInstance();
       vc = (VC) o;
       vc.readExternal(in);
</pre></blockquote>
<ol start="9"><li>Some original VC objects comparison are done through "==" rather than "equals" method.  However, with externalization, we cannot have instance variable with final modifier hence this will no longer hold.  Therefore, we have to override the "equals" method and use that method for comparison.
</li></ol><blockquote>
<table class="wiki">
<tr><td> <strong>Details list of classes to be changed</strong> 
</td></tr><tr><td> org.jmlspecs.jml4.esc.gc.lang.KindOfAssertion 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.cvc3.Cvc3Visitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed 
</td></tr><tr><td> org.jmlspecs.jml4.esc.result.lang.Result 
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.WlpVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.lang.* 
</td></tr><tr><td> Esc4Web.src.ProveVcProgram 
</td></tr><tr><td> Esc4Web.src.ProveVc 
</td></tr></table>
</blockquote>
<h4 id="ChangesImpactAnalysis">Changes Impact Analysis</h4>
<blockquote>
<p>
The objective of these changes is to improve the program proving time in distributed environment.  Current java default serialization process uses heavily reflection machanism to accomplish object serialization.  This could lead to performance issue as in this project where one of the major requirements is to improve the speed of process.  The externalizable interface gives developers the full control of how to serialize object explicitly bypassing reflection.  This interface improves dramatically the speed of serialization by ~ 50% to ~60%.
</p>
</blockquote>
<blockquote>
<p>
Overall, most of the required changes did not affect the existing API except changing "==" comparison to "equals" comparison and changing default serialization calls to custom serialization calls.  Nevertheless, improve speed comes with extra cost of implementing and maintaining custom serialization methods.
</p>
</blockquote>
<blockquote>
<p>
Current serialization process of all Vcs based on WhileTests is about 1500 ms (using System.currentTimeInMilliseconds()) and with improved externalization process, it is about 500 ms. Conclusion, externalization did improve the speed of serialization process. However, it did not improve the overall proving process. Hence, current serialization process is not the principal performance bottleneck.
</p>
</blockquote>
<blockquote>
<p>
<strong> The patch for the above changes can be found in the attachment section. </strong>
</p>
</blockquote>
<h3 id="IsabelleandSimplifyAdapter">Isabelle and Simplify Adapter</h3>
<h4 id="ChangesElicitation1">Changes Elicitation</h4>
<blockquote>
<p>
The changes are made specifically in SimplifyAdapter and IsabelleAdapter classes.  The major changes is to avoid spwaning a new prover process for each VC to be proved.  The classes to be changed are:
</p>
</blockquote>
<ul><li>org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapater
</li><li>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter
</li></ul><p>
The API of these two classes remains intact.  Only the internal behavior of getting external prover process is changed.  The changes are shown below:
</p>
<blockquote>
<p>
<strong> SimplifyAdapter.java </strong>
</p>
</blockquote>
<blockquote>
<p>
<a href="https://group0j.stu01.encs.concordia.ca:9443/trac/changeset/225/JML4/dev/trunk/org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/esc/provercoordinator/prover/simplify/SimplifyAdapter.java?old=30&amp;old_path=JML4%2Fsourceforge%2Fcurrent%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fsimplify%2FSimplifyAdapter.java">See the changes</a>
</p>
</blockquote>
<blockquote>
<p>
<strong> IsabelleAdapter.java </strong>
</p>
</blockquote>
<blockquote>
<p>
<a href="https://group0j.stu01.encs.concordia.ca:9443/trac/changeset?old_path=%2FJML4%2Fsourceforge%2Fcurrent%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fisabelle%2FIsabelleAdapter.java&amp;old=30&amp;new_path=JML4%2Fdev%2Ftrunk%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fisabelle%2FIsabelleAdapter.java&amp;new=225">see the changes</a>
</p>
</blockquote>
<h4 id="ChangesImpactAnalysis1">Changes Impact Analysis</h4>
<blockquote>
<p>
One of the principal performance bottlenecks is spawning new provers process for each VC to be proved.  Current design spawns too many prover processes (a.k.a: based on the current tests set, the simplify prover is being called ~4000 times and isabelle prover ~ 1000 times.  For every call, a new process is created at the beginning and deleted at the end.  In addition, the processes are not being created and used sequentially.  At a given point in time, there are &gt; 10 isabelle processes and simplify processes simultaneously.  This continuous create/delete of process is time consuming and affect heavily overall performance of the system.  Therefore, the changes proposed eliminate unnecessary creation and deletion of provers' process.  It suggests the reuse of the same process for all VCs to be proved.
</p>
</blockquote>
<blockquote>
<p>
<strong> Pros &amp; Cons </strong>
</p>
</blockquote>
<blockquote>
<p>
Pros:
</p>
</blockquote>
<ol><li>Avoid unnecessary creation/deletion of process
</li><li>Improve performance significantly
</li><li>The process will be maintain in a more controlled way (rather to have unexpected # of processes running at the same time, we are guarantee to have fix amount of process running at any moment).
</li><li>No changes in API, this changes will not propagate to other classes that depend on these classes (SimplifyAdapter and IsabelleAdapater).
</li></ol><blockquote>
<p>
Cons:
</p>
</blockquote>
<ol><li>Strong coupling on the Isabelle and Simplify API.
</li><li>No recovery mechanism exists in proposed change.
</li></ol><p>
 
 
</p>
<blockquote>
<p>
The changes are very promising.  Based on the BigWhileTest, with the original provers' adapter, the test runs ~28 secs over 4 servers whereas with the new adapters, the same test runs 7 to 9 secs. <a href="/trac/wiki/ProversBenchmark" class="wiki">see section Proving Performance</a>
</p>
</blockquote>
<h2 id="References">References</h2>
<p>
1. Process Impact -- Process Goodies to Support Software Development <a href="http://www.processimpact.com/goodies.shtml" class="ext-link"><span class="icon">http://www.processimpact.com/goodies.shtml</span></a>
</p>
</div>
   </div>
   
    
    
  
  
   
  
  <script type="text/javascript">
   addHeadingLinks(document.getElementById("searchable"), "Link to this section");
  </script>
 
 
</div>

<script type="text/javascript">searchHighlight()</script>


</div>





 </body>
</html>

