<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Disco - Impact Analysis</title>
 
<link href="../style.css" rel="stylesheet" type="text/css" /></head>
<body>





<div id="main">






<div class="wiki" id="content">

 
  
  
   
   <div class="wikipage">
    <div id="searchable"><h1 id="ImpactAnalysis">Impact Analysis</h1>
<p>
<div class="wiki-toc">
<h4>Table of Contents</h4>
<ol><li class="active"><a href="#a1.Introduction">1. Introduction</a><ol><li class="active"><a href="#a1.1ImplicationsoftheProposedChange">1.1 Implications of the Proposed Change</a></li><li class="active">
<a href="#a1.2SystemElementsAffectedbytheProposedChange">1.2 System Elements Affected by the Proposed Change</a></li></ol></li><li class="active"><a href="#a2.DistributedComponent">2. Distributed Component</a><ol><li class="active"><a href="#a2.1DistributedVCs">2.1 Distributed VCs</a><ol><li class="active"><a href="#a2.1.1ChangesElicition">2.1.1 Changes Elicition</a></li></ol></li><li class="active"><a href="#a2.2SecondPrototype">2.2 Second Prototype</a><ol><li class="active"><a href="#a2.2.1ChangesElicitation">2.2.1 Changes Elicitation</a></li></ol></li><li class="active"><a href="#a2.3VCObjectSerialization">2.3 VC Object Serialization</a><ol><li class="active"><a href="#a2.3.1ChangesElicitation">2.3.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.3.2ChangesImpactAnalysis">2.3.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.4IsabelleandSimplifyAdapter">2.4 Isabelle and Simplify Adapter</a><ol><li class="active"><a href="#a2.4.1ChangesElicitation">2.4.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.4.2ChangesImpactAnalysis">2.4.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.5IsabelleProcessInteractiveMode">2.5 Isabelle Process Interactive Mode</a><ol><li class="active"><a href="#a2.5.1ChangesElicitation">2.5.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.5.2ChangesImpactAnalysis">2.5.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.6ProverProcessPool">2.6 Prover Process Pool</a><ol><li class="active"><a href="#a2.6.1ChangesElicitation">2.6.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.6.2ChangesImpactAnalysis">2.6.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.7VcCache">2.7 VcCache</a><ol><li class="active"><a href="#a2.7.1ChangesElicitation">2.7.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.7.2ChangesImpactAnalysis">2.7.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.8BurdenTesting">2.8 Burden Testing</a><ol><li class="active"><a href="#a2.8.1ChangesElicitation">2.8.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.8.2ChangesImpactAnalysis">2.8.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.9ChangemadetoCoretoforClientSideGui">2.9 Change made to Core to for Client Side Gui</a><ol><li class="active"><a href="#a2.9.1ChangesElicitation">2.9.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.9.2ChangesImpactAnalysis">2.9.2 Changes Impact Analysis</a></li></ol></li><li class="active"><a href="#a2.10MergeWithNewerSourceForgeJMLJava4">2.10 Merge With Newer SourceForge JML Java 4</a><ol><li class="active"><a href="#a2.10.1ChangesElicitation">2.10.1 Changes Elicitation</a></li><li class="active">
<a href="#a2.10.2ChangesImpactAnalysis">2.10.2 Changes Impact Analysis</a></li></ol><li class="active"></li></li></ol></li><li class="active"><a href="#a3.BoogieComponent">3. Boogie Component</a><ol><li class="active"><a href="#a3.1Boogie">3.1 Boogie</a><ol><li class="active"><a href="#a3.1.1ChangesElicitation">3.1.1 Changes Elicitation</a></li></ol><li class="active"></li></li></ol><li class="active"><a href="#References">References</a></li></li></ol></div>
 
</p>
<h2 id="a1.Introduction">1. Introduction</h2>
<p>
This document will cover the changes the JML4 Disco project may bring to the overall JML4 Project. We will consider the risks involved, changes in the overall quality, performance and requirements as well as the consequence to any change proposed
. the  The following is a check-list of things to consider when performing our impact analysis. 
</p>
<h3 id="a1.1ImplicationsoftheProposedChange">1.1 Implications of the Proposed Change</h3>
<ul><li>Identify any existing requirements in the baseline that conflict with the proposed change. 
</li><li>Identify any other pending requirement changes that conflict with the proposed change. 
</li><li>What are the consequences of not making the change? 
</li><li>What are possible adverse side effects or other risks of making the proposed change? 
</li><li>Will the proposed change adversely affect performance requirements or other quality attributes? 
</li><li>Will the change affect any system component that affects critical properties such as safety and security, or involve a product change that triggers recertification of any kind? 
</li><li>Is the proposed change feasible within known technical constraints and current staff skills? 
</li><li>Will the proposed change place unacceptable demands on any computer resources required for the development, test, or operating environments? 
</li><li>Must any tools be acquired to implement and test the change? 
</li><li>How will the proposed change affect the sequence, dependencies, effort, or duration of any tasks currently in the project plan? 
</li><li>Will prototyping or other user input be required to verify the proposed change? 
</li><li>How much effort that has already been invested in the project will be lost if this change is accepted? 
</li><li>Will the proposed change cause an increase in product unit cost, such as by increasing third-party product licensing fees? 
</li><li>Will the change affect any marketing, manufacturing, training, or customer support plans? 
</li></ul><h3 id="a1.2SystemElementsAffectedbytheProposedChange">1.2 System Elements Affected by the Proposed Change</h3>
<ul><li>Identify any user interface changes, additions, or deletions required. 
</li><li>Identify any changes, additions, or deletions required in reports, databases, or data files. 
</li><li>Identify the design components that must be created, modified, or deleted. 
</li><li>Identify hardware components that must be added, altered, or deleted. 
</li><li>Identify the source code files that must be created, modified, or deleted. 
</li><li>Identify any changes required in build files. 
</li><li>Identify existing unit, integration, system, and acceptance test cases that must be modified or deleted. 
</li><li>Estimate the number of new unit, integration, system, and acceptance test cases that will be required. 
</li><li>Identify any help screens, user manuals, training materials, or other documentation that must be created or modified. 
</li><li>Identify any other systems, applications, libraries, or hardware components affected by the change. 
</li><li>Identify any third party software that must be purchased. 
</li><li>Identify any impact the proposed change will have on the projectâ€™s software project management plan, software quality assurance plan, software configuration management plan, or other plans. 
</li><li>Quantify any effects the proposed change will have on budgets of scarce resources, such as memory, processing power, network bandwidth, real-time schedule. 
</li><li>Identify any impact the proposed change will have on fielded systems.
</li></ul><h2 id="a2.DistributedComponent">2. Distributed Component</h2>
<h3 id="a2.1DistributedVCs">2.1 Distributed VCs</h3>
<p>
In order to prove VC remotely, we have to change some classes in the eclipse core project.  
</p>
<h4 id="a2.1.1ChangesElicition">2.1.1 Changes Elicition</h4>
<ul><li>Class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed</tt> was created. 
</li><li>Class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise_timings</tt> was added only for benchmarking and outputting of results. 
</li><li>The <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProverStrategyFactory</tt> was modified to include the new distributed prover strategy. 
</li><li>Several classes in the Distributed Prototype have had to be altered so they implement <tt>java.io.Serializable</tt>: 
</li><li><tt>org.jmlspecs.jml4.esc.gc.lang.KindOfAssertion</tt> 
</li><li><tt>org.jmlspecs.jml4.esc.result.lang.Result</tt> 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VC</tt> 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcOperator</tt> 
</li><li>Several classes had the 'final' keyword removed from the declaration of instance variables to allow for serialization: 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcLogicalExpression</tt> 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcArithExpression</tt> 
</li><li>In class <tt>org.jmlspecs.jml4.esc.Esc</tt> some variables were changed to be 'final' for serialization purposes. 
</li><li>Class <tt>org.jmlspecs.jml4.esc.vc.lang.VcArithExpression</tt>, <tt>org.jmlspecs.jml4.esc.vc.lang.VcLogicalExpression</tt> and <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> also had changes made for custom serialization overriding. 
</li><li>The instance variable <tt>operator</tt> in class <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> was made public for the purpose of serialization. 
</li><li>Outputs and logging were added to class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise</tt> and several method calls are made with null parameters to make serialization possible. 
</li><li>In class <tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> instance variables <tt>CompierlerOptions</tt> and <tt>ProblemReporter</tt> are set to null to allow serialization. 
</li><li>Several classes derived from <tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> have <tt>problemReporter</tt> set to null to allow serialization. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter</tt> 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapter</tt> 
</li><li>In class <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveEntireVC::prove(VcProgram)</tt>, variable <tt>problemReporter</tt> is null to allow serialization. 
</li><li>In class <tt>org.jmlspecs.jml4.esc.Esc</tt> several changes were made pertinent to timing and printout.
</li><li>Eclipse-class <tt>org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment</tt> was given an empty constructor to facilitate the creation of serializable classes which inherit from it. 
</li><li>Eclipse-class <tt>org.eclipse.jdt.internal.compiler.lookup.LookupEnvironmentEmptyForSerialization</tt> is an "empty class to allow easy serialization."
</li></ul><h3 id="a2.2SecondPrototype">2.2 Second Prototype</h3>
<h4 id="a2.2.1ChangesElicitation">2.2.1 Changes Elicitation</h4>
<ul><li><tt>org.jmlspecs.jml4.compiler.JmlCompilerExtension</tt> was changed. (see svn changelog 102) 
</li><li><tt>org.jmlspecs.jml4.compiler.JmlCompilerOptions</tt> had distributed options added to it. (see svn changelog 102) 
</li><li><tt>org.jmlspecs.jml4.esc.Esc</tt> was changed for threading. (see svn changelog 102) 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.ProverAdapter</tt> instance variables CompierlerOptions and ProblemReporter are now transient. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.cvc3.Cvc3Adapter</tt> a problem is reported every time a failed attempt to invoke cvc3 is made.  
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter</tt> a problem is reported every time isabelle fails to launch.  
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.SimplifyAdapter</tt> a problem is reported every time simplify fails to launch. 
</li><li>In <tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed</tt> the name of the properties configuration file in which URLs are found was changed. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise</tt> underwent several changes. 
</li><li><tt>org.jmlspecs.jml4.esc.provercoordinator.strategy.ProverStrategyFactory</tt> was modified again. 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VC</tt> underwent several changes for custom serialization. 
</li><li>Class <tt>org.jmlspecs.jml4.esc.vc.lang.VcOperator</tt>, <tt>org.jmlspecs.jml4.esc.vc.lang.VcQuantifier</tt> and <tt>org.jmlspecs.jml4.esc.vc.lang.VcRelativeExpression</tt> was changes made for custom serialization overriding. 
</li><li><tt>org.jmlspecs.jml4.esc.vc.lang.VcTypeBinding</tt> is a new type to allow serialization. 
</li><li>The existing tests in package <tt>org.jmlspecs.eclipse.jdt.core.tests.esc</tt> were copied to <tt>org.jmlspecs.eclipse.jdt.core.tests.esc.distributed</tt> and modified for applicability to distribution. 
</li><li><tt>org.eclipse.jdt.core.compiler.org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcPiecewise.java</tt> commented out 5 lines in the proveVC(...) method in order to prevent adding to and checking the cache. 
</li><li><tt>org.eclipse.jdt.core.compiler.org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter.java</tt> Added a check in matchingTheoryFileExists(...) method to ensure that the file is readable before attempting the read. 
</li></ul><h3 id="a2.3VCObjectSerialization">2.3 VC Object Serialization</h3>
<h4 id="a2.3.1ChangesElicitation">2.3.1 Changes Elicitation</h4>
<p>
<strong>The following are the details of the changes needed to improve serialization process:</strong> 
</p>
<p>
One of the possible ways of speeding up current VC serialization process is using <strong>Externalizable</strong> interface.   
Externalizable is a subclass of Serializable.  It provides more control to the programmer over what and how the objects are being serialized and it produces smaller serialized object in terms of size. 
</p>
<p>
The Externalizable interface defines 2 methods: readExternal(ObjectInput in) and writeExternal(ObjectOutput out).  Unlike default serialization, programmers have the full control over what and how to serialize the object instance's variables.  Nevertheless, this also implies the needs of extra codes of dealing with serialization process. 
</p>
<p>
Our concern in JML4Disco is serializing Vc and all its sub-types objects, therefore the changes required to use externalizable interface are: 
</p>
<ol><li>VC class implements Externalizable interface. 
</li><li>VC class and all its subclasses must add 2 new methods: readExternal() and writeExternal().  Note that all subclasses must override the VC's readExternal() and writeExternal methods. 
</li><li>All Vc's subclass must explicitly call super.readExternal() and super.writeExternal() in order to serialize parent's attributes. 
</li><li>The order of serialization and de-serialization must match properly.  For instance: 
<pre class="wiki"> public void readExternal(ObjectInput in) throws IOException, 
 ClassNotFoundException { 
  super.readExternal(in); 
  this.operator = new VcOperator(); 
  this.operator.readExternal(in); 
 } 

 public void writeExternal(ObjectOutput out) throws IOException { 
  super.writeExternal(out); 
  this.operator.writeExternal(out); 
 } 
</pre></li><li>The VC and its subclass must have a default constructor that takes no argument. 
</li><li>All attributes that will be serialized must not be final. 
</li><li>Must replace the default ObjectOutput.write() and ObjectInput.read() calls in ProveVcProgram.java, ProveVcDistributed.java with appropriate readExternal(), and writeExternal() methods. 
</li><li>The inheritance makes externalization process more complex.  As we expect to receive any type of vc at the server, to deserialize the vc into appropriate type requires serializing that information during the serialization process and uses reflection get the appropriate type and then de-serialize the object. 
</li></ol><blockquote>
<p>
Prior serialize the VC object, store the actual type of VC: 
</p>
<pre class="wiki">  out.writeUTF(vc.getClass().getName()); 
  vc.writeExternal(out); 
</pre></blockquote>
<blockquote>
<p>
On receiving a serialized object: 
</p>
<pre class="wiki">  in = new ObjectInputStream(request.getInputStream());             
  String vcClassName = in.readUTF(); 
  Class c = Class.forName(vcClassName); 
  Object o = c.newInstance(); 
  vc = (VC) o; 
  vc.readExternal(in); 
</pre></blockquote>
<ol start="9"><li>Some original VC objects comparison are done through "==" rather than "equals" method.  However, with externalization, we cannot have instance variable with final modifier hence this will no longer hold.  Therefore, we have to override the "equals" method and use that method for comparison. 
</li></ol><table class="wiki">
<tr><td> <strong>Details list of classes to be changed</strong> 
</td></tr><tr><td> org.jmlspecs.jml4.esc.gc.lang.KindOfAssertion 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.cvc3.Cvc3Visitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.strategy.ProveVcDistributed 
</td></tr><tr><td> org.jmlspecs.jml4.esc.result.lang.Result 
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.WlpVisitor 
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.lang.* 
</td></tr><tr><td> Esc4Web.src.ProveVcProgram 
</td></tr><tr><td> Esc4Web.src.ProveVc 
</td></tr></table>
<h4 id="a2.3.2ChangesImpactAnalysis">2.3.2 Changes Impact Analysis</h4>
<p>
The objective of these changes is to improve the program proving time in distributed environment.  Current java default serialization process uses heavily reflection machanism to accomplish object serialization.  This could lead to performance issue as in this project where one of the major requirements is to improve the speed of process.  The externalizable interface gives developers the full control of how to serialize object explicitly bypassing reflection.  
This interface improves dramatically the speed of serialization by ~ 50% to ~60%. 
Overall, most of the required changes did not affect the existing API except changing "==" comparison to "equals" comparison and changing default serialization calls to custom serialization calls.  Nevertheless, improve speed comes with extra cost of implementing and maintaining custom serialization methods. 
Current serialization process of all Vcs based on WhileTests is about 1500 ms (using System.currentTimeInMilliseconds()) and with improved externalization process, it is about 500 ms. Conclusion, externalization did improve the speed of serialization process. However, it did not improve the overall proving process. Hence, current serialization process is not the principal performance bottleneck. 
</p>
<p>
<strong> The patch for the above changes can be found in the attachment section. </strong>
</p>
<h3 id="a2.4IsabelleandSimplifyAdapter">2.4 Isabelle and Simplify Adapter</h3>
<h4 id="a2.4.1ChangesElicitation">2.4.1 Changes Elicitation</h4>
<p>
The changes are made specifically in SimplifyAdapter and IsabelleAdapter classes.  The major changes is to avoid spwaning a new prover process for each VC to be proved.  The classes to be changed are: 
</p>
<ul><li>org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapater 
</li><li>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter 
</li></ul><p>
The API of these two classes remains intact.  Only the internal behavior of getting external prover process is changed.  The changes are shown below: 
<strong> SimplifyAdapter.java </strong> 
</p>
<p>
<a href="https://group0j.stu01.encs.concordia.ca:9443/trac/changeset/225/JML4/dev/trunk/org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/esc/provercoordinator/prover/simplify/SimplifyAdapter.java?old=30&amp;old_path=JML4%2Fsourceforge%2Fcurrent%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fsimplify%2FSimplifyAdapter.java">See the changes</a> 
</p>
<p>
<strong> IsabelleAdapter.java </strong> 
</p>
<p>
<a href="https://group0j.stu01.encs.concordia.ca:9443/trac/changeset?old_path=%2FJML4%2Fsourceforge%2Fcurrent%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fisabelle%2FIsabelleAdapter.java&amp;old=30&amp;new_path=JML4%2Fdev%2Ftrunk%2Forg.eclipse.jdt.core%2Fcompiler%2Forg%2Fjmlspecs%2Fjml4%2Fesc%2Fprovercoordinator%2Fprover%2Fisabelle%2FIsabelleAdapter.java&amp;new=225">see the changes</a> 
</p>
<h4 id="a2.4.2ChangesImpactAnalysis">2.4.2 Changes Impact Analysis</h4>
<p>
One of the principal performance bottlenecks is spawning new provers process for each VC to be proved.  Current design spawns too many prover processes 
(a.k.a: based on the current tests set, the simplify prover is being called ~4000 times and isabelle prover ~ 1000 times.  For every call, a new process is created at the beginning and deleted at the end.  In addition, the processes are not being created and used sequentially.  At a given point in time, there are &gt; 10 isabelle processes and simplify processes simultaneously.  This continuous create/delete of process is time consuming and affect heavily overall performance of the system.  Therefore, the changes proposed eliminate unnecessary creation and deletion of provers' process.  It suggests the reuse of the same process for all VCs to be proved. 
</p>
<p>
<strong> Pros &amp; Cons </strong> 
</p>
<p>
Pros: 
</p>
<ol><li>Avoid unnecessary creation/deletion of process 
</li><li>Improve performance significantly 
</li><li>The process will be maintain in a more controlled way (rather to have unexpected # of processes running at the same time, we are guarantee to have fix amount of process running at any moment). 
</li><li>No changes in API, this changes will not propagate to other classes that depend on these classes (SimplifyAdapter and IsabelleAdapater). 
</li></ol><p>
Cons: 
</p>
<ol><li>Strong coupling on the Isabelle and Simplify API. 
</li><li>No recovery mechanism exists in proposed change. 
</li></ol><p>
The changes are very promising.  Based on the BigWhileTest, with the original provers' adapter, the test runs ~28 secs over 4 servers whereas with the new adapters, the same test runs 7 to 9 secs. <a href="/trac/wiki/ProversBenchmark" class="wiki">see section Proving Performance</a> 
</p>
<h3 id="a2.5IsabelleProcessInteractiveMode">2.5 Isabelle Process Interactive Mode</h3>
<p>
From previous milestone, we were be able to improve the performance of proving VCs by limiting x number of provers' processes and reusing those processes.  Nevertheless, there still have room for improvement.  The current approach of using Isabelle process is not efficient.  For each VC that we want to prove with Isabelle, we have to create a file, open the file, write the lemma into that file, close the file;  then, we fetch the file name into Isabelle process which internally open the file and read the theory.  If the theory is valid, we delete the file, otherwise we keep the file.  As we can notice that there are too many file CRUD operations.  These operations are expensive and should be minimized.  So the proposed changes is to eliminate the need of creating theory file.  Instead, we should fetch the theory string directly into isabelle and if the theory is not valid, then we write to the file.
</p>
<h4 id="a2.5.1ChangesElicitation">2.5.1 Changes Elicitation</h4>
<blockquote>
<p>
In order to accommodate the proposed changes, following classes will be modified:
</p>
</blockquote>
<blockquote>
<table class="wiki">
<tr><td> <strong> Class </strong> 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/esc/provercoordinator/prover/isabelle/IsabelleAdapter.java 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/esc/provercoordinator/prover/isabelle/IsabelleProcessPool.java 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/esc/provercoordinator/prover/isabelle/IsabelleVisitor.java 
</td></tr></table>
</blockquote>
<blockquote>
<p>
<a href="/trac/changeset/438" title="Ticket #190 Avoid unnecessary write to file and fetch theory file into  ..." class="changeset">see code level changes</a>
</p>
</blockquote>
<h4 id="a2.5.2ChangesImpactAnalysis">2.5.2 Changes Impact Analysis</h4>
<p>
The change has low impact on the system. We did not change any behavior of the system.  Instead, we modified the way of using Isabelle process more efficiently.  This change has following advantage over original approach: 
</p>
<ul><li>Eliminate unnecessary file  CRUD operation.
</li><li>Eliminate potential of getting "Too many files open" error: 
</li></ul><blockquote>
<blockquote>
<p>
In Linux environment, every user including root have the limitation on the number of file that can remain open during a session.  When we fetch theory file into Isabelle and reuse that process for other theories, all theory files will not be close until the process is closed.  With the change mentioned above, this issue is solved.
</p>
</blockquote>
</blockquote>
<h3 id="a2.6ProverProcessPool">2.6 Prover Process Pool</h3>
<p>
In order to maximize the power of multiple cores, we plan to implement the process pool concept for each prover.   
</p>
<h4 id="a2.6.1ChangesElicitation">2.6.1 Changes Elicitation</h4>
<p>
Few new classes will be created 
</p>
<table class="wiki">
<tr><td> <strong>Details list of classes changed/created</strong> 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.ProcessPool 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleProcessPool 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyProcessPool 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapater 
</td></tr><tr><td> org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter 
</td></tr></table>
<ul><li>ProcessPool models the each prover process pool.  The ProcessPool holds a queue of a given prover's process that is free to be used.  This is an abstract class. 
</li></ul><h4 id="a2.6.2ChangesImpactAnalysis">2.6.2 Changes Impact Analysis</h4>
<p>
These changes will slightly affect Isabelle and Simplify adapters.  We add another layer of abstraction on generating/maintaining process using process pool concept.  The existing getProverProcess() method in adapter will be removed.  This change affects 2 tests as they have a dependency on getProverProcess() method.  Other than that, there will have minimum impact on the existing core.
</p>
<h3 id="a2.7VcCache">2.7 VcCache</h3>
<h4 id="a2.7.1ChangesElicitation">2.7.1 Changes Elicitation</h4>
<p>
In an effort to increase the speed at which VcPrograms are proved by the proving servers, caching of already proven Vc's has been proposed. This will 
eliminate the proving time for Vc's that exist in the cache, thus reducing the proving servers load.  
</p>
<h4 id="a2.7.2ChangesImpactAnalysis">2.7.2 Changes Impact Analysis</h4>
<p>
The impact to the current distributed server is minimal. The VcCache is a stand alone component, and the current system will interface with that component. 
The VcCache will not have the ability to modify any component of the distribution server, thus the only impact it will have will be dictated by the server itself. The proving server will now be required to return the prover which proved the VC so as to accommodate the caching. 
The JML4 core class ProveVcPiecewise has now had a method overloaded so as to be able to return to the proving server the prover that was able to prove the VC. The behaviour of this overloaded method is identical to the original, and so other server technologies which used the previous core will be able to use this core without any impact. 
</p>
<h3 id="a2.8BurdenTesting">2.8 Burden Testing</h3>
<p>
In order to allow any test extending AbstractRegressionTest to be rerun several times consecutively in a loop (providing the main means of heavily burdening the system), a call to a method in the PerformanceMeterFactory class must be suppressed. The method is only called once, and from within the same class. The method, AssertUniqueScenario(String scenario) seems to only add any created scenarios to a private HashSet to which there are no accessors or mutators. However, the method throws an IllegalArgumentException if the scenario is not unique, which may be caught by any tests/classes using the PerformanceMeterFactory (and there are many). This means, that if those classes use the exception for control flow, there may be repercussions. 
A throttling mechanism was added to the VcProgramDispatching class to pause dispatching for small amounts of time if the best server available has too many pending VCs. The delay time as well as the pending vc threshold should be configurable from the Configuration pages being created in milestone 5  
</p>
<h4 id="a2.8.1ChangesElicitation">2.8.1 Changes Elicitation</h4>
<p>
Few new classes will be created 
</p>
<table class="wiki">
<tr><td> <strong>Details list of classes changed/created</strong> 
</td></tr><tr><td> <a href="/trac/browser/JML4/dev/trunk/org.eclipse.test.performance/src/org/eclipse/test/internal/performance/PerformanceMeterFactory.java" class="source">JML4/dev/trunk/org.eclipse.test.internal.performance/PerformanceMeterFactory</a> 
</td></tr></table>
<h4 id="a2.8.2ChangesImpactAnalysis">2.8.2 Changes Impact Analysis</h4>
<p>
Insignificant impact on the existing system.
</p>
<h3 id="a2.9ChangemadetoCoretoforClientSideGui">2.9 Change made to Core to for Client Side Gui</h3>
<p>
In order to add client side Enabling and Disabling of Boogie and Distributed proving, a number of classes in org.eclipse.jdt.core will be added to in order to accomodate new compiler options. Most of these changes are low impact in that they will not harm or disable any pre-existing compiler option behavior (they are simply new attributes of type String). The one exception is the compiler option jmlEscProverStrategy which stores the prover strategy to use as a string, such as "proveVcPiecewise" or "distributed". Currently, the only use of this compiler option is to toggle on and off the Distributed strategy, but it should remain able to take other strings as well. <br /><br />
Since enabling/disabling Distribution will be controlled by a checkbox, the existing architecture will automatically store the strings "ENABLED" or "DISABLED", depending on the status of the control. As such, we cannot use the jmlEscProverStrategy compiler option directly to store this status, as it will contain "ENABLED"/"DISABLED" and not the correct strings "distributed", etc. Therefore, it must me stored as a seperate option and a check must be done to set jmlEscProverStrategy to the correct string as appropriate. 
</p>
<p>
<a href="/trac/attachment/wiki/ImpactAnalysis/ClientSideGui.jpeg" style="padding:0; border:none"><img title="Client Side Gui Changes" src="images/ClientSideGui.jpeg" alt="Client Side Gui Changes" /></a> 
</p>
<p>
Diagram showing the relationship between the changes that were necessary for the Client Side UI changes 
</p>
<h4 id="a2.9.1ChangesElicitation">2.9.1 Changes Elicitation</h4>
<p>
In order to accommodate the proposed changes, following classes will be modified:
</p>
<table class="wiki">
<tr><td> <strong> Class </strong> 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/compiler/JmlCompilerExtension.java 
</td></tr><tr><td> org.eclipse.jdt.core/compiler/org/jmlspecs/jml4/compiler/JmlCompilerOptions.java 
</td></tr><tr><td> org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java 
</td></tr><tr><td> org.jmlspecs.eclipse.jdt.ui/src/org/jmlspecs/eclipse/jdt/ui/preferences/JmlConfigurationBlock.java 
</td></tr><tr><td> org.jmlspecs.eclipse.jdt.ui/src/org/jmlspecs/eclipse/jdt/ui/preferences/PreferencesMessages.java 
</td></tr><tr><td> org.jmlspecs.eclipse.jdt.ui/src/org/jmlspecs/eclipse/jdt/ui/preferences/PreferencesMessages.properties 
</td></tr></table>
<p>
<a href="/trac/changeset/457" title="--See ticket #188" class="changeset">see code level changes</a>
</p>
<h4 id="a2.9.2ChangesImpactAnalysis">2.9.2 Changes Impact Analysis</h4>
<p>
The changes have low impact on the system. 
</p>
<ul><li>Note though that is essential that when the other prover strategies are implemented later as copiler options, that they appropriately overwrite the jmlEscProverStrategy string.
</li></ul><h3 id="a2.10MergeWithNewerSourceForgeJMLJava4">2.10 Merge With Newer SourceForge JML Java 4</h3>
<p>
The week of February 10th, the current version of JMLJava4 was initially taken from sourceforge and merged with Disco's current trunk in a branch. Both the distributed and boogie teams then evaluated the consistancy of that branch with respect to their respective features. 
</p>
<h4 id="a2.10.1ChangesElicitation">2.10.1 Changes Elicitation</h4>
<p>
For the distributed team, there is fairly low impact. 
</p>
<table class="wiki">
<tr><td> <strong>Details list of classes changed/created</strong> </td><td> <strong>Brief problem description</strong>
</td></tr><tr><td> org.jmlspecs.jml4.esc.gc.lang/KindOfassertion </td><td> Needs serialization 
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.lang/VcTypeBinding </td><td> Does not exist in sourceforge.... may have been <br /> created solely for the original distribution prototype
</td></tr><tr><td> org.jmlspecs.jml4.esc.vc.lang/VC.java </td><td> Has an association with VcTypeBinding 
</td></tr></table>
<p>
The existence of VcTypeBinding must be investigated: it may be an unnecessary change leftover from the original round-robin distribution prototype.  
</p>
<h4 id="a2.10.2ChangesImpactAnalysis">2.10.2 Changes Impact Analysis</h4>
<h2 id="a3.BoogieComponent">3. Boogie Component</h2>
<h3 id="a3.1Boogie">3.1 Boogie</h3>
<h4 id="a3.1.1ChangesElicitation">3.1.1 Changes Elicitation</h4>
<blockquote>
<table class="wiki">
<tr><td> JmlCompilerExtension.java </td><td> Changes in this file are meant to allow a new proving strategy: "Boogie", along with compiler options to turn it on and off. 
</td></tr><tr><td>JmlCompilerOptions.java </td><td> Changes in this file add a compiler option for EnableJmlBoogie 
</td></tr></table>
</blockquote>
<p>
<br />
</p>
<blockquote>
<table class="wiki">
<tr><td> <strong>New package</strong> 
</td></tr><tr><td> org.jmlspecs.jml4.boogie 
</td></tr><tr><td>This package contains all pertinent files for proving using boogie. These new elements are based on existing object used for verification through simplify, isabelle and cvc3
</td></tr></table>
</blockquote>
<p>
<br />
</p>
<blockquote>
<table class="wiki">
<tr><td> <strong>Details list of classes added</strong> </td><td>  
</td></tr><tr><td> Boogie.java </td><td> A compiler extension that enables Java code to be passed through Microsoft Boogie in order to formally verify JML DbC annotations. 
</td></tr><tr><td> BoogieAdapter.java </td><td> Wraps the Boogie runtime into a Java class that can be called from Eclipse's compilation stack. 
</td></tr><tr><td> BoogieSource.java </td><td> Represents a buffer of Boogie source code that will be passed to a Boogie runtime object. 
</td></tr><tr><td> BoogieSourcePoint.java </td><td>  Represents a point in a Boogie source code file. Used to map points in Boogie source back to a Java source file. 
</td></tr><tr><td> BoogieVisitor.java  </td><td> Traverses each node in the AST producing equivalent boogie code.
</td></tr></table>
</blockquote>
<h2 id="References">References</h2>
<p>
1. Process Impact -- Process Goodies to Support Software Development <a href="http://www.processimpact.com/goodies.sh" class="ext-link"><span class="icon">http://www.processimpact.com/goodies.sh</span></a>
</p>
</div>
   </div>
   
    
    
  
  
   
  
  <script type="text/javascript">
   addHeadingLinks(document.getElementById("searchable"), "Link to this section");
  </script>
 
 
</div>

<script type="text/javascript">searchHighlight()</script>


</div>





 </body>
</html>

