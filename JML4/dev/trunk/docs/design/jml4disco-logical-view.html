<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Disco - Jml4Disco-Logical View</title>
 
<link href="../style.css" rel="stylesheet" type="text/css" /></head>
<body>





<div id="main">






<div class="wiki" id="content">

 
  
  
   
   <div class="wikipage">
    <div id="searchable"><h1 id="LogicalView">Logical View</h1>
<p>
<div class="wiki-toc">
<h4>Table of Contents</h4>
<ol><li class="active"><a href="#a1.Introduction">1. Introduction</a></li><li class="active">
<a href="#a2.LogicalView">2. Logical View</a><ol><li class="active"><a href="#a2.1DistributedProgramVerification-RelevantComponents">2.1 Distributed Program Verification-Relevant Components</a><ol><li class="active"><a href="#a2.1.1High-LevelDesign">2.1.1 High-Level Design</a></li><li class="active">
<a href="#a2.1.2ClassDiagram">2.1.2 Class Diagram</a></li><li class="active">
<a href="#a2.1.3ClassDescription">2.1.3 Class Description</a><ol><li class="active"><a href="#a2.1.3.1ProveVcProgram">2.1.3.1 ProveVcProgram</a></li><li class="active">
<a href="#a2.1.3.2VcProgramDispatchingServer">2.1.3.2 VcProgramDispatchingServer</a></li><li class="active">
<a href="#a2.1.3.3AbstractRemoteServer">2.1.3.3 AbstractRemoteServer</a></li><li class="active">
<a href="#a2.1.3.4RemoteTomCatServer">2.1.3.4 RemoteTomCatServer</a></li><li class="active">
<a href="#a2.1.3.5ServerQueue">2.1.3.5 ServerQueue</a></li><li class="active">
<a href="#a2.1.3.6ServerQueueFactory">2.1.3.6 ServerQueueFactory</a></li><li class="active">
<a href="#a2.1.3.7ServerComparator">2.1.3.7 ServerComparator</a></li><li class="active">
<a href="#a2.1.3.8IServerProfile">2.1.3.8 IServerProfile</a></li><li class="active">
<a href="#a2.1.3.9ProveVc">2.1.3.9 ProveVc</a></li><li class="active">
<a href="#a2.1.3.10ProveVcServer">2.1.3.10 ProveVcServer</a></li><li class="active">
<a href="#a2.1.3.11ProveVcThread">2.1.3.11 ProveVcThread</a></li><li class="active">
<a href="#a2.1.3.12ServerProfile">2.1.3.12 ServerProfile</a></li></ol></li><li class="active"><a href="#a2.1.4InteractionDiagram">2.1.4 Interaction Diagram</a><ol><li class="active"><a href="#a2.1.4.1ProvingaVcProgram">2.1.4.1 Proving a VcProgram</a></li><li class="active">
<a href="#a2.1.4.2LoadBalancing">2.1.4.2 Load Balancing</a></li><li class="active">
<a href="#a2.1.4.3RemoteProveVcServerImplementation">2.1.4.3 RemoteProveVcServer Implementation</a></li><li class="active">
<a href="#a2.1.4.4ConfigurationInterface:ServerSide">2.1.4.4 Configuration Interface: Server Side</a></li></ol><li class="active"></li></li></ol></li><li class="active"><a href="#a2.2TheoremProverProcessesRefactoring">2.2 Theorem Prover Processes Refactoring</a><ol><li class="active"><a href="#a2.2.1TheSimplifyandIsabelleAdapters">2.2.1 The Simplify and Isabelle Adapters</a><ol><li class="active"><a href="#a2.2.1.1ClassDiagram">2.2.1.1 Class Diagram</a></li><li class="active">
<a href="#a2.2.1.2InteractionDiagram">2.2.1.2 Interaction Diagram</a></li></ol></li><li class="active"><a href="#a2.2.2SimplifyandIsabelleProcessPool">2.2.2 Simplify and Isabelle Process Pool</a><ol><li class="active"><a href="#a2.2.2.1ClassDiagram">2.2.2.1 Class Diagram</a></li><li class="active">
<a href="#a2.2.2.2InteractionDiagram">2.2.2.2 Interaction Diagram</a></li></ol><li class="active"></li></li></ol><li class="active"><a href="#a2.3.BoogieComponents">2.3. Boogie Components</a><ol><li class="active"><a href="#a2.3.1ClassDiagram">2.3.1 Class Diagram</a></li><li class="active">
<a href="#a2.3.2ClassesDescription">2.3.2 Classes Description</a><ol><li class="active"><a href="#a2.3.2.1Boogie">2.3.2.1 Boogie</a></li><li class="active">
<a href="#a2.3.2.2BoogieAdapter">2.3.2.2 BoogieAdapter</a></li><li class="active">
<a href="#a2.3.3.3BoogieParser">2.3.3.3 BoogieParser</a></li><li class="active">
<a href="#a2.3.3.4BoogieVisitor">2.3.3.4 BoogieVisitor</a></li><li class="active">
<a href="#a2.3.3.5BoogieSource">2.3.3.5 BoogieSource</a></li><li class="active">
<a href="#a2.3.3.6BoogieSourcePoint">2.3.3.6 BoogieSourcePoint</a></li><li class="active">
<a href="#a2.3.3.7BoogieSymbolTable">2.3.3.7 BoogieSymbolTable</a></li><li class="active">
<a href="#a2.3.3.8BoogieVariableDeclFinderVisitor">2.3.3.8 BoogieVariableDeclFinderVisitor</a></li></ol><li class="active"><a href="#a2.3.4InteractionDiagrams">2.3.4 Interaction Diagrams</a><ol><li class="active"><a href="#a2.3.4.1BoogieVisitor">2.3.4.1 BoogieVisitor</a></li><li class="active">
<a href="#a2.3.4.2BoogieSource">2.3.4.2 BoogieSource</a></li></ol></li></li></ol></li></li></ol></li></ol></div>

</p>
<h2 id="a1.Introduction">1. Introduction</h2>
<p>
The logical view conveys the functional requirement of the system.
</p>
<h2 id="a2.LogicalView">2. Logical View</h2>
<p>
This section of the wiki provides all the information about the logical view of the key components of the JML4 Disco.
</p>
<h3 id="a2.1DistributedProgramVerification-RelevantComponents">2.1 Distributed Program Verification-Relevant Components</h3>
<p>
One of the major components of JML4 Disco is the ability to prove VCs distributively.  This section of the wiki page provides all the architecturally significant design of the JML4 Disco distributed environment.  The architecture adapted is the logical layering scheme presented by Fowler with a presentation layer, a domain logic layer and data source layer. 
</p>
<h4 id="a2.1.1High-LevelDesign">2.1.1 High-Level Design</h4>
<p>
The servers involved in Distributed Program Verification are layered as follows: in the topmost layer, the presentation layer, Java Servlets serve to marshall and demarshall the information found in Http messages passed from Client or Prover-Servers to Dispatcher. In the layer just below, the application layer, are classes relevant to the logic of distributing program verification.
Beneath the application layer is the Domain layer, which contains classes pertinent to the verification itself. The following is a simple (deliberately incomplete) diagram to convey the layers with some of the more relevant classes they contain shown, followed by a more complete, intricate class diagram.
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/Layers.png" style="padding:0; border:none"><img src="images/Layers.png" /></a><br />
Figure 2.1.1: Layering Architectural Design of JML4 Disco Distributed Subsystem
</p>
<h4 id="a2.1.2ClassDiagram">2.1.2 Class Diagram</h4>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/ClassDiagram_DistributedLoadBalancing.png" style="padding:0; border:none"><img title="Class Diagram for distributed VCs load balancing" src="images/ClassDiagram_DistributedLoadBalancing.png" alt="Class Diagram for distributed VCs load balancing" /></a><br />
Figure 2.1.2a: Class Diagram of JML4 Disco Distributed Subsystem
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/ClientGUI_ClassDiagram.jpeg" style="padding:0; border:none"><img title="Client GUI configuration Class Diagra" src="images/ClientGUI_ClassDiagram.jpeg" alt="Client GUI configuration Class Diagra" /></a><br />
Figure 2.1.2b: Class Diagram for JML4 Disco Client's Configuration
</p>
<h4 id="a2.1.3ClassDescription">2.1.3 Class Description</h4>
<h5 id="a2.1.3.1ProveVcProgram">2.1.3.1 ProveVcProgram</h5>
<p>
This class is essentially responsible for de-marshalling messages received from a Client. As a servlet, it receives messages from a Client in the form of Http requests, which include Java-Serialized <tt>VcProgram</tt> objects. These <tt>VcProgram</tt> objects are then passed to the <tt>VcProgramDispatchingServer.</tt>
</p>
<h5 id="a2.1.3.2VcProgramDispatchingServer">2.1.3.2 VcProgramDispatchingServer</h5>
<p>
While another class is exclusively responsible for de-marshalling <tt>VcPrograms</tt> objects received in a message, this class serves as a Facade to the rest of the Dispatching functionality.
</p>
<h5 id="a2.1.3.3AbstractRemoteServer">2.1.3.3 AbstractRemoteServer</h5>
<p>
The <tt>AbstractRemoteServer</tt> provides some basic functionality and describes the interface for classes which will represent the protocol details involved in sending a message to a remote ProveVc Server.
</p>
<h5 id="a2.1.3.4RemoteTomCatServer">2.1.3.4 RemoteTomCatServer</h5>
<p>
An implementation of abstract class <tt>AbstractRemoteServer</tt>, <tt>RemoteTomCatServer</tt> sends a Vc object to a remote server using HTTP protocol, expecting that remote server to be running Apache TomCat. At the end of Milestone 4, this is the only existing implementation of <tt>AbstractRemoteServer</tt>.
</p>
<h5 id="a2.1.3.5ServerQueue">2.1.3.5 ServerQueue</h5>
<p>
This implementation of Java standard interface <tt>java.util.Queue</tt> encapsulates the logic behind load balancing. The Dispatcher only sees a queue which gives it the instance of <tt>AbstractRemoteServer</tt> most capable of receiving and responding to a message.
</p>
<h5 id="a2.1.3.6ServerQueueFactory">2.1.3.6 ServerQueueFactory</h5>
<p>
In the event that the implementation of <tt>ServerQueue</tt> changes, the <tt>ServerQueueFactory</tt> reduces coupling.
</p>
<h5 id="a2.1.3.7ServerComparator">2.1.3.7 ServerComparator</h5>
<p>
This class contributes to how the <tt>ServerQueue</tt> class chooses the instance of <tt>AbstractRemoteServer</tt> most capable of receiving and responding to a message.
</p>
<h5 id="a2.1.3.8IServerProfile">2.1.3.8 IServerProfile</h5>
<p>
Instances of <tt>AbstractRemoteServer</tt> receive <tt>IServerProfile</tt> objects as part of the responses they get from the remote machines they communicate with.
</p>
<h5 id="a2.1.3.9ProveVc">2.1.3.9 ProveVc</h5>
<p>
This class is essentially responsible for de-marshalling messages received from a Dispatcher. As a servlet, it receives messages from a Dispatcher in the form of Http requests, which include Java-Serialized <tt>Vc</tt> objects. These <tt>Vc</tt> objects are then passed to the <tt>ProveVcServer.</tt>
</p>
<h5 id="a2.1.3.10ProveVcServer">2.1.3.10 ProveVcServer</h5>
<p>
While another class is exclusively responsible for de-marshalling <tt>Vc</tt> objects received in a message, this class serves as a Facade to the rest of the proving functionality.
</p>
<h5 id="a2.1.3.11ProveVcThread">2.1.3.11 ProveVcThread</h5>
<p>
For each VC that is to be proved, there's is one ProveVcThread.  This class provides the ability to prove multiple VC concurrently by spawnning new ProveVcThread for each vc.
</p>
<h5 id="a2.1.3.12ServerProfile">2.1.3.12 ServerProfile</h5>
<p>
The Server Profile is a helper class for the performance data being retrieved from remote servers.  This class models the remote host with its available resources and usage such as number of cores, size of memory, average CPU load, etc...
</p>
<h4 id="a2.1.4InteractionDiagram">2.1.4 Interaction Diagram</h4>
<h5 id="a2.1.4.1ProvingaVcProgram">2.1.4.1 Proving a VcProgram</h5>
<p>
While still based on the <a href="/trac/wiki/FirstPrototype" class="wiki">original prototype</a>, the latest implementation has been heavily refactored to incorporate a more scalable and maintainable design.
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/InteractionDiagram-DistributedProverStrategyImplementation-ProveVCProgram-Servlet.png" style="padding:0; border:none"><img src="images/InteractionDiagram-DistributedProverStrategyImplementation-ProveVCProgram-Servlet.png" /></a><br />
Figure 2.1.4.1 Sequence Diagram for proving a VcProgram
</p>
<p>
<br />
Relevant Components
</p>
<ul><li><span class="underline"><tt>prVcProg:ProveVcProgram</tt> -</span> Servlet which recieves a <tt>VCProgram</tt> via an HTTP POST request and dispatches that <tt>VCProgram</tt>'s VCs to be proven concurrently by remote provers.
</li><li><span class="underline"><tt>HttpServletRequest</tt> -</span> Instance of Apache TomCat interface <tt>javax.servlet.http.HttpServletRequest</tt>.
</li><li><span class="underline"><tt>HttpServletResponse</tt> -</span> Instance of Apache TomCat interface <tt>javax.servlet.http.HttpServletResponse</tt>.
</li><li><span class="underline"><tt>reqIn:ObjectInputStream</tt> -</span> Standard Java class <tt>java.io.ObjectInputStream</tt> which - within the scope of this example - reads from the <tt>InputStream</tt> provided by the <tt>HttpServletRequest</tt> object. The data is read out of an HTTP POST request, sent by the client.
</li><li><span class="underline"><tt>respOut:ObjectOutputStream</tt> -</span> Standard Java class <tt>java.io.ObjectOutputStream</tt> which - in the scope of this example - writes to the <tt>OutputStream</tt> provided by the <tt>HttpServletResponse</tt> object. The data written to the <tt>OutputStream</tt> will eventually be written to an HTTP response.
</li><li><span class="underline"><tt>ProveVcProgramServer</tt> -</span> A 'Static class' meant to act as a facade to Prove-Vc-functionality, so as to separate proving logic from communication and marshaling/de-marshaling.
</li><li><span class="underline"><tt>RemoteProveVcServerQueueFactory</tt> -</span> Since <tt>RemoteProveVcServerQueue</tt> is an abstract class so as to make the load balancing logic transparent, the factory allows us to instantiate the queues without strong coupling.
</li><li><span class="underline"><tt>RemoteProveVcServerQueue</tt> -</span> An abstract class which will control load balancing logic. This class is abstract; concrete implementations will depend on the protocol being used to connect to a given Prove Vc Server. (see below)
</li><li><span class="underline"><tt>ProveVcThread</tt> -</span> Not a <tt>Thread</tt> at all but an implementation of runnable, which contains encapsulates the logic for sending a Prove Vc Server a request asynchronously.
</li><li><span class="underline"><tt>ThreadPool</tt> -</span> In the implementation there is no class 'ThreadPool.' Someone should change the diagram to make this object lifeline be an instanec of class <tt>java.util.concurrent.Executor</tt> named 'ThreadPool' for clarity.
</li></ul><h5 id="a2.1.4.2LoadBalancing">2.1.4.2 Load Balancing</h5>
<p>
Class <tt>ServerQueue</tt> object serves to encapsulate load balancing. At the moment, it inherits the implementation of a <tt>java.util.PriorityQueue</tt>, though not the interface, via delegation; an instance of <tt>ServerQueue</tt> contains instance variable <tt>queue</tt> of type <tt>java.util.PriorityQueue</tt> to which it delegates most of its method calls. <br />
The second instance variable of class <tt>ServerQueue</tt> is of type <tt>ServerComparator</tt> and is used by the <tt>java.util.PriorityQueue</tt> to ascertain the order in which <tt>AbstractRemoteServer</tt> objects should be in the queue. <br />
</p>
<h5 id="a2.1.4.3RemoteProveVcServerImplementation">2.1.4.3 RemoteProveVcServer Implementation</h5>
<p>
Coupling has been reduced by abstracting away the logic to connect to remote Prove VC Servers into <tt>RemoteProveVcServer</tt> (an abstract class) objects. In the event that future implementations don't use TomCat / Servlet implementations, changing from one platform to another should be easier. The following is an interaction diagram representing what happens when the Thread Pool executes a <tt>ProveVcThread</tt> using a <tt>RemoteProveVcTomCatServer</tt> implementation, sending an HTTP request to a remote machine, including a Vc.
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/InteractionDiagram-DistributedProverStrategyImplementation-RemoteProveVcTomCatServer.png" style="padding:0; border:none"><img src="images/InteractionDiagram-DistributedProverStrategyImplementation-RemoteProveVcTomCatServer.png" /></a><br />
Figure 2.1.4.3 Sequence Diagram for proving a VC remotely
</p>
<p>
Relevant Components
</p>
<ul><li><span class="underline"><tt>ProveVcThread</tt> -</span> Not a <tt>Thread</tt> at all but an implementation of runnable, which contains encapsulates the logic for sending a Prove Vc Server a request asynchronously.
</li><li><span class="underline"><tt>servReqIn:ObjectOutputStream</tt> -</span> Standard Java class <tt>java.io.ObjectOutputStream</tt> which - in the scope of this example - writes to the <tt>OutputStream</tt> provided by the <tt>URLConnection</tt> object. When this <tt>ObjectOutputStream</tt> is closed, the data written to the <tt>OutputStream</tt> is written to an HTTP POST request.
</li><li><span class="underline"><tt>URLConnection</tt> -</span> Standard Java class <tt>java.net.URLConnection</tt> that represent a communications link between the application and a URL, or in this instance, the remote VCProgram-Prover-Servlet <tt>ProveVCProgram</tt>.
</li><li><span class="underline"><tt>servRespIn:ObjectInputStream</tt> -</span> Standard Java class <tt>java.io.ObjectInputStream</tt> which - within the scope of this example - reads from the <tt>InputStream</tt> provided by the <tt>URLConnection</tt> object. The data is read out of an HTTP POST request, sent by the remote Prove-VCProgram Servlet <tt>ProveVCProgram</tt>.
</li><li><span class="underline"><tt>ProveVC</tt> -</span> This Servlet recieves a <tt>VC</tt> via an HTTP POST request and proves it using ESC4, JML4's static verification component.
</li></ul><h5 id="a2.1.4.4ConfigurationInterface:ServerSide">2.1.4.4 Configuration Interface: Server Side</h5>
<p>
Two new features will be added to the distributed component in the form of configuration interfaces for the server machines, meant to be used by an administrator. The implementation used will be a web application, implemented using Servlets running on a Tomcat web server. As such, while the communication between remote machines during program verification may someday be able to move away from using Http to communicate, Dispatcher and Prover servers will always have to be deployed on web servers which include some Java web container, such as Apache Tomcat.
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/InteractionDiagram-Config-Servlet.png" style="padding:0; border:none"><img src="images/InteractionDiagram-Config-Servlet.png" /></a><br />
Figure 2.1.4.4 Sequence Diagram for configuring server
</p>
<p>
Dispatcher Server's Web-Based  Configuration Interface<br />
A layered architecture will be used to develop the configuration interface. In the very top layer, Java Server Pages will render as views, and Java Servlets will receive Http requests and interface with the layer just below, the application layer. In the application layer there will be an interface-independent implementation of a Front Controller, as well as class definitions for Command objects. Below this layer will be the existing JML4Disco classes which will be configured.
<br /><br />
Prover Server's Web-Based Configuration Interface<br />
The design proposed for the Prover Server's Configuration Interface will be identical to that of the Dispatcher's. As such, classes and types common to both implementations should be reused.
</p>
<h3 id="a2.2TheoremProverProcessesRefactoring">2.2 Theorem Prover Processes Refactoring</h3>
<h4 id="a2.2.1TheSimplifyandIsabelleAdapters">2.2.1 The Simplify and Isabelle Adapters</h4>
<p>
The adapters are objects that provide bridges between java jvm and theorem prover which are external processes.  The adapters deal with the actual communication with the provers' process.  In this milestone, the team has decided to change the internal behavior of SimplifyAdapter and IsabelleAdapter to avoid unnecessary creation/deletion of process every time the adapters are being called.  This change will improve significantly the performance of proving.
</p>
<h5 id="a2.2.1.1ClassDiagram">2.2.1.1 Class Diagram</h5>
<p>
No change from JML4 project.  Only internal behavior of handling process was modified.
</p>
<h5 id="a2.2.1.2InteractionDiagram">2.2.1.2 Interaction Diagram</h5>
<p>
The below diagram shows the general behavior of creating new prover's process and how to maintain process' life in a long run.  Note that the behavior shown in the diagram also applied to SimplifyAdapter.
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/InteractionDiagram-SpawnningOneProcessForSimplifyAndIsabelle.png" style="padding:0; border:none"><img title="upload updated interaction diagram for isabelleAdapter" src="images/InteractionDiagram-SpawnningOneProcessForSimplifyAndIsabelle.png" alt="upload updated interaction diagram for isabelleAdapter" /></a>
Figure 2.2.1.2: Sequence Diagram for spawnning one process of simplify and isabelle
</p>
<ul><li>org.jmlspecs.jml4.esc.provercoordinator.prover.simplify.SimplifyAdapter
</li><li>org.jmlspecs.jml4.esc.provercoordinator.prover.isabelle.IsabelleAdapter
</li></ul><h4 id="a2.2.2SimplifyandIsabelleProcessPool">2.2.2 Simplify and Isabelle Process Pool</h4>
<p>
From the previous milestone, we were able to improve significantly the performance of proving by limiting only one process per theorem prover.  However, this does not take advantage of the full potential of multi-core systems.  Hence, during this milestone, we will aiming to generate more processes for each theorem prover (specifically for Simplify and Isabelle ESC4) in a controlled way. The following class diagram shows the changes of the Isabelle and Simplify adapters as well as new classes necessary to implement this 'process pool' concept.
</p>
<h5 id="a2.2.2.1ClassDiagram">2.2.2.1 Class Diagram</h5>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/ClassDiagram_ProcessPool.png" style="padding:0; border:none"><img title="Process Pool Class diagram" src="images/ClassDiagram_ProcessPool.png" alt="Process Pool Class diagram" /></a><br />
Figure 2.2.2.1: Sequence Diagram for process pool concept
</p>
<p>
Whenever, the adapter needs a process, it asks for a idle process by calling ProcessPool object's getFreeProcess() method.  Similarly, once the adapter is no longer needed for the holding process, it release it by calling releaseProcess(Process p) method.
</p>
<p>
ProcessPool object store a list of a given prover's processes.  The available processes is created on the fly (as needed) until the number of created processes hits the maximum threshold.  By default, the number of process allowed is the number of core on the host machine * 2.  
</p>
<h5 id="a2.2.2.2InteractionDiagram">2.2.2.2 Interaction Diagram</h5>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/Sequence_Diagram_Prover_Process_Pool.png" style="padding:0; border:none"><img title="sequence diagram for process pool" src="images/Sequence_Diagram_Prover_Process_Pool.png" alt="sequence diagram for process pool" /></a><br />
Figure 2.2.2.2: Sequence Diagram for Prover Process Pool
</p>
<h3 id="a2.3.BoogieComponents">2.3. Boogie Components</h3>
<h4 id="a2.3.1ClassDiagram">2.3.1 Class Diagram</h4>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/ClassDiagram_Boogie_SymbolTable_DeclFinder.png" style="padding:0; border:none"><img title="new boogie class diagram M5" src="images/ClassDiagram_Boogie_SymbolTable_DeclFinder.png" alt="new boogie class diagram M5" /></a><br />
Figure 2.3.1: Class Diagram for Boogie Components
</p>
<h4 id="a2.3.2ClassesDescription">2.3.2 Classes Description</h4>
<h5 id="a2.3.2.1Boogie">2.3.2.1 Boogie</h5>
<p>
The Boogie object is a default compiler extension that enables the Java code to be passed through Boogie. For this to happen, there are two compiler options which must 
be enabled:
</p>
<ul><li> jmlBoogieEnabled set to true
</li><li> jmlEscProverStrategy: "JML4BOOGIE"
</li></ul><p>
Boogie's preCodeGeneration method is called by Eclipse's compilation mechanism before Java bytecode is generated for output. When the function is called, it passes down the compiler object as well as the compilation unit (the unit is the root AST node of a Java source file to parse) to the BoogieAdapter through the process function. 
</p>
<h5 id="a2.3.2.2BoogieAdapter">2.3.2.2 BoogieAdapter</h5>
<p>
The Boogie adapter is responsible for instantiating a BoogieSource object (which holds boogie source). The adapter translates from java to Boogie by calling the boogieVisitor visit function and passing the BoogieSource object to it. The adapter is then responsible for writing the source to a temporary Boogie .bpl source file and executing it through the boogie runtime. 
</p>
<h5 id="a2.3.3.3BoogieParser">2.3.3.3 BoogieParser</h5>
<p>
For now, there is a parser function called parseResult which resides in the boogie adapter. Error messages (results) from Boogie, return a column and row of where the mistake has occured. The parser is responsible parsing that msg and creating a BoogieSourcePoint. With the source point, it then uses the bougieSource getTermAtPoint function to map back to a particular AST node where the error originated from. Using the AST node the parser is now able to return an error msg to the problem reporter with the nth term where it occured. In the future, the Boogie Parser will be taken out of the Boogie Adapter.
</p>
<h5 id="a2.3.3.4BoogieVisitor">2.3.3.4 BoogieVisitor</h5>
<p>
The Boogie visitor has all the node traversal methods. It uses the visitor pattern since when the the visitor's static visit method gets called by the adapter, it gets dynamically dispatched to the proper visit method. When a specific node is visited, the BoogieOutput passed from the adapter is appended with the newly generated boogie source. 
</p>
<h5 id="a2.3.3.5BoogieSource">2.3.3.5 BoogieSource</h5>
<p>
The BoogieSource object is responsible for holding boogie source code which will in tern be written to a temporary file and passed to Boogie runtime by the adapter. The object also holds a table called boogieTable which maps BoogieSourcePoints to particular AST nodes. It is necessary to have this mapping so that when boogie returns an error message with a particular BoogieSourcePoint ( a column and a row in the boogie source) we can map backwards to a particular AST node. This mapping occurs whenever Boogie source is appended. 
</p>
<h5 id="a2.3.3.6BoogieSourcePoint">2.3.3.6 BoogieSourcePoint</h5>
<p>
A Boogie Source Point holds a row and column. It also has a compare method. It primarily used by the BoogieSource object to map points in boogie to AST nodes. 
</p>
<h5 id="a2.3.3.7BoogieSymbolTable">2.3.3.7 BoogieSymbolTable</h5>
<p>
The BoogieSymbolTable class is used to map all local variable declarations to unique, scope independent symbol names. This is necessary because Boogie has only two scopes, global scope and local scope (procedure local). In addition to this limitation, all local declarations must be declared at the beginning of any procedure implementation before any other statements. A problematic scenario that illustrates the need for this component is as follows:
</p>
<pre class="wiki">    public void method() {
        int x = 2;
        if (true) {
            int x = 10; 
        }
    }
</pre><p>
Without symbol passification, Boogie would be generated as:
</p>
<pre class="wiki">    procedure method() {
        var x : int;
        var x : int;
        x := 2;
        if (true) {
            x := 10;
        }
    }
</pre><p>
To solve this problem, symbols are uniquely generated starting from the symbol 'a', 'b', ..., 'z', 'aa', and so forth. The correctly generated Boogie using variable passification would be:
</p>
<pre class="wiki">    procedure method() {
        var a : int;
        var b : int;
        a := 2;
        if (true) {
            b := 10;
        }
    }
</pre><h5 id="a2.3.3.8BoogieVariableDeclFinderVisitor">2.3.3.8 BoogieVariableDeclFinderVisitor</h5>
<p>
The BoogieVariableDeclFinderVisitor class is used to group all local variable declarations in a method and emit them at the top of a MethodDeclaration before any statements are printed to the buffer. These variables are first passified using the BoogieSymbolTable described above. 
</p>
<h4 id="a2.3.4InteractionDiagrams">2.3.4 Interaction Diagrams</h4>
<h5 id="a2.3.4.1BoogieVisitor">2.3.4.1 BoogieVisitor</h5>
<p>
The following diagram shows the general behavior of the boogieVisitor. This diagram keeps a certain level of abstraction and will be broken down in later diagrams.
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/boogieVisitor.gif" style="padding:0; border:none"><img title="boogieVisitor" src="images/boogieVisitor.gif" alt="boogieVisitor" /></a><br />
Figure 2.3.4.1 Sequence Diagram for BoogieVisitor behavior
</p>
<h5 id="a2.3.4.2BoogieSource">2.3.4.2 BoogieSource</h5>
<p>
Here we see how the BoogieSource object gets appended. It internally delegates to a string Buffer but also contains a map of boogiePoints to map the Java source (AST terms) to Boogie code. 
</p>
<p>
<a href="/trac/attachment/wiki/Jml4Disco-LogicalView/boogiesourceseq.gif" style="padding:0; border:none"><img title="Boogie Source sequence diagram" src="images/boogiesourceseq.gif" alt="Boogie Source sequence diagram" /></a><br />
Figure 2.3.4.2 Sequence Diagram for BoogieSource behavior
</p>
</div>
   </div>
   
    
    
  
  
   
  
  <script type="text/javascript">
   addHeadingLinks(document.getElementById("searchable"), "Link to this section");
  </script>
 
 
</div>

<script type="text/javascript">searchHighlight()</script>


</div>





 </body>
</html>

