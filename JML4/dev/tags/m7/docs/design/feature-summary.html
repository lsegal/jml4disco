<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Disco - Feature Summary</title>
 

        <link href="../style.css" rel="stylesheet" type="text/css" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-type" />
    </head>
<body>





<div id="main">






<div class="wiki" id="content">

 
  
  
   
   <div class="wikipage">
    <div id="searchable"><h1 id="FeatureSummary">Feature Summary</h1>
<p>
<div class="wiki-toc">
<h4>Table of Contents</h4>
<ol><li class="active"><a href="#a1.Introduction">1. Introduction</a></li><li class="active">
<a href="#a2.SummaryofFeatures">2. Summary of Features</a><ol><li class="active"><a href="#a2.1FeaturesofJMLDistribution">2.1 Features of JML Distribution</a><ol><li class="active"><a href="#a2.1.1DistributedDischargingofVCs">2.1.1 Distributed Discharging of VCs</a></li><li class="active">
<a href="#a2.1.2Multi-threadedverification">2.1.2 Multi-threaded verification</a></li><li class="active">
<a href="#a2.1.3EclipseUIforEnablingDisablingDistributedProving">2.1.3 Eclipse UI for Enabling/Disabling Distributed Proving</a></li><li class="active">
<a href="#a2.1.4WebUIformanagingDistributedServercomponents">2.1.4 Web UI for managing Distributed Server components</a></li></ol></li><li class="active"><a href="#a2.2FeaturesofBoogieCompilerExtension">2.2 Features of Boogie Compiler Extension</a><ol><li class="active"><a href="#a2.2.1JMLRequiresandEnsuresClausesSupportMethodCalls">2.2.1 JML Requires and Ensures Clauses Support Method Calls</a></li><li class="active">
<a href="#a2.2.2FieldInitializationforSimpleNon-ArrayTypes">2.2.2 Field Initialization for Simple (Non-Array) Types</a></li><li class="active">
<a href="#a2.2.3One-DimensionalArraySupport">2.2.3 One-Dimensional Array Support</a></li><li class="active">
<a href="#a2.2.4BasicSupportforPolymorphism">2.2.4 Basic Support for Polymorphism</a></li><li class="active">
<a href="#a2.2.5BlockLocalSupport">2.2.5 Block Local Support</a></li></ol><li class="active"><a href="#a2.3LimitationsoftheBoogieCompilerExtension">2.3 Limitations of the Boogie Compiler Extension</a></li></li></ol></li></ol></div>

</p>
<h2 id="a1.Introduction">1. Introduction</h2>
<p>
The purpose of this document is to list the features we have completed to give the current status of the project. The document will also discuss the limitations of our current architecture and potential future works.
</p>
<h2 id="a2.SummaryofFeatures">2. Summary of Features</h2>
<h3 id="a2.1FeaturesofJMLDistribution">2.1 Features of JML Distribution</h3>
<h4 id="a2.1.1DistributedDischargingofVCs">2.1.1 Distributed Discharging of VCs</h4>
<p>
One of the issues with original JML4 is the poor performance of the proving process.  The current JML4 Disco system provides support to verify the code correctness distributively.  The source code is broken down into VcPrograms which represent method and further into VCs which represents each possible way that the method can be traversed.  The current distributed implementation is not robust; in the event that a server fails, the system does not recover nicely.  Neverthless, the implementation is not dependent upon use of tomcat/http/web for communication.
</p>
<h4 id="a2.1.2Multi-threadedverification">2.1.2 Multi-threaded verification</h4>
<p>
Originally the verification units were proved sequential despite their independent nature.  By implementing multi-threading, practical use was made of the modular properties of the first order verification conditions.
</p>
<h4 id="a2.1.3EclipseUIforEnablingDisablingDistributedProving">2.1.3 Eclipse UI for Enabling/Disabling Distributed Proving</h4>
<p>
The current JML4-Disco enhanced Eclipse UI provides the functionality that allows user to choose alternate proving strategy for code verification.  The limitation of the current configuration mechanism is the mutually exclusive use of the strategies.  If the distributed verification is chosen, other methods of verification will be disabled.
</p>
<p>
<br /><a href="/trac/attachment/wiki/FeatureSummary/UseCase6and7.png" style="padding:0; border:none"><img src="images/UseCase6and7.png" /></a><br />
Figure 2.1.3: Shows the option pane to enable and disable distributed proving.
</p>
<h4 id="a2.1.4WebUIformanagingDistributedServercomponents">2.1.4 Web UI for managing Distributed Server components</h4>
<p>
The Web UI provides an interface for an administrator to manage the configuration of the dispatcher and prover.  The dispatcher configuration page provides functionality to add and remove remote provers to the system as well as enabling/disabling server-side caching.  The prover configuration page provides functionality to adjust the number of parallel prover processes.
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Dispatcher-AddServers.png" style="padding:0; border:none"><img src="images/Dispatcher-AddServers.png" /></a><br />
Figure 2.1.4.1: Interface to add new prover server
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Dispatcher-RemoveServers.png" style="padding:0; border:none"><img src="images/Dispatcher-RemoveServers.png" /></a><br />
Figure 2.1.4.2: Interface to remove existing prover server
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Dispatcher-EnableCaching.png" style="padding:0; border:none"><img src="images/Dispatcher-EnableCaching.png" /></a><br />
Figure 2.1.4.3: Enabling Caching Mechanism
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Dispatcher-DisableCaching.png" style="padding:0; border:none"><img src="images/Dispatcher-DisableCaching.png" /></a><br />
Figure 2.1.4.4: Disabling Caching Mechanism
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Prover-Workbench.png" style="padding:0; border:none"><img src="images/Prover-Workbench.png" /></a><br />
Figure 2.1.4.5: Prover Configuration GUI
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/Prover-SetNumberOfProverProcesses.png" style="padding:0; border:none"><img src="images/Prover-SetNumberOfProverProcesses.png" /></a><br />
Figure 2.1.4.6: GUI for configuring number of process for each prover
</p>
<h3 id="a2.2FeaturesofBoogieCompilerExtension">2.2 Features of Boogie Compiler Extension</h3>
<h4 id="a2.2.1JMLRequiresandEnsuresClausesSupportMethodCalls">2.2.1 JML Requires and Ensures Clauses Support Method Calls</h4>
<p>
One limitation of the earlier Boogie implementation was that it could not handle an ensures clause having a method call. This functionality is common, especially with recursive code. An example of such recursive code is an implementation of the Fibonacci sequence with JML ensure annotations. The following example code snippet showcases such a java method and and how it would be translated to Boogie:
</p>
<p>
<i>in Java:</i>
</p>
<pre class="wiki">	//@ requires n &gt;= 0;
	//@ ensures n &lt; 2 ==&gt; \result == n;
	//@ ensures n &gt;= 2 ==&gt; \result == fib(n-1) + fib(n-2);
	public int fib(int n) {
		if (n &lt; 2) return n;
		return fib(n-1) + fib(n-2);
	}
</pre><p>
<i>in Boogie:</i>
</p>
<pre class="wiki">    type $Ref;
    function $fn.tests.esc.A.fib(this: $Ref, a: int) returns (int);
    axiom (forall this: $Ref, a: int :: (
        ((a &lt; 2) ⇒ ($fn.tests.esc.A.fib(this, a) == a)) &amp;&amp; 
        ((a &gt;= 2) ⇒ ($fn.tests.esc.A.fib(this, a) == 
            ($fn.tests.esc.A.fib(this, (a - 1)) + $fn.tests.esc.A.fib(this, (a - 2)))))));
    procedure tests.esc.A.fib(this: $Ref, a: int) returns ($r: int) 
    requires (a &gt;= 0); 
    ensures ((a &lt; 2) ⇒ ($r == a)); 
    ensures ((a &gt;= 2) ⇒ ($r == ($fn.tests.esc.A.fib(this, (a - 1)) + $fn.tests.esc.A.fib(this, (a - 2))))); 
    {
	    var b: int;
	    var c: int;
	    if (a &lt; 2) {
		    $r := a;
		    return;
	    }
	    call b := tests.esc.A.fib(this, (a - 1));
	    call c := tests.esc.A.fib(this, (a - 2));
	    $r := (b + c);
	    return;
    }
</pre><p>
Note that in Boogie, procedures can only be called as statements, which are only valid inside of procedures. Therefore, to properly translate the JML ensures clause, a Boogie "function" of the the same name as the procedure is added with prefix <tt>$fn.</tt>. This function can be called as an expression, and asserts that the ensures clauses all hold true (using an axiom). This solution was only made possible by using a Boogie AST to reorder and insert function nodes before printing the output. More information on how nodes are traversed can be found in the <a href="/trac/wiki/Jml4Disco-LogicalView#a2.3.4InteractionDiagrams" class="wiki">Logical View</a>.
</p>
<p>
In the Eclipse UI we can see how Boogie can be used to prove the Fibonacci sequence:
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/fibonacci-ide.png" style="padding:0; border:none"><img title="Fibonacci in Eclipse" src="images/fibonacci-ide.png" alt="Fibonacci in Eclipse" /></a><br />
Figure 2.2.1: Static verification of Fibonacci method in Eclipse IDE using JML4/Disco
</p>
<h4 id="a2.2.2FieldInitializationforSimpleNon-ArrayTypes">2.2.2 Field Initialization for Simple (Non-Array) Types</h4>
<p>
Another significant milestone was completing the ability to initialize field values. In Boogie, global variables (any variable not defined within a procedure) can only be assigned to from within a procedure. As such, to support implicit field initialization whenever a object is instantiated, a new procedure for each class must be added (the fully qualified class name with the <tt>$initFields</tt> suffix) that performs such assignments. This method must also be called directly by all constructors before performing any other actions.
</p>
<p>
By using a reordered AST over the original Boogie implementation which directly outputted Boogie source after visiting the Java AST, it becomes considerably easier to inject new procedures and assignments without affecting the source code. An example field declaration with initialization can be seen in the following example:
</p>
<pre class="wiki">    public int counter = 2;

    public Counter() { 
        //@ assert counter == 2;
    }
</pre><p>
The above code is converted into Boogie as:
</p>
<pre class="wiki">   type $Ref;
   var Counter.counter: [$Ref] int;

   procedure Counter.$initFields(this: $Ref) 
   modifies Counter.counter; 
   ensures Counter.counter[this] == 2; 
   {
       Counter.counter[this] := 2;
   }
   procedure Counter.Counter(this: $Ref) 
   {
       call Counter.$initFields(this);
       assert Counter.counter[this] == 2;
   }
</pre><p>
In addition to implicit/explicit class attribute initialization we also support common Java usage of fields. The following screenshots showcase some of basic field usage.
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/c.png" style="padding:0; border:none"><img title="Fields in Eclipse" src="images/c.png" alt="Fields in Eclipse" /></a><br />
Figure 2.2.2: Statically verifying modified fields in Eclipse IDE using JML4/Disco
</p>
<h4 id="a2.2.3One-DimensionalArraySupport">2.2.3 One-Dimensional Array Support</h4>
<p>
Support for basic arrays of primitive types arrays of objects have been added. Currently only one-dimensional arrays are supported. In the future it would be possible to extend support to include multi-dimensional and jagged array types by implementing the following AST nodes <a href="/trac/wiki/BoogieTraceability#JN49" class="wiki">JN49</a> and <a href="/trac/wiki/BoogieTraceability#JN49" class="wiki">JN55</a>. This should not have serious impact on the current design. There is currently untested support for multi-dimensional array references if the declarations mentioned above are implemented. The complicated part of implementing such arrays in Boogie would be describing the types of all the elements in the arrays, as this has proved more difficult than expected.
</p>
<h4 id="a2.2.4BasicSupportforPolymorphism">2.2.4 Basic Support for Polymorphism</h4>
<p>
Using Boogie's type system, the <tt>instanceof</tt> expression in Java was implemented. This allows support for polymorphism and static checking of subclass types that was previously unsupported. The following screenshot shows an example of how this can work:
</p>
<p>
<a href="/trac/attachment/wiki/FeatureSummary/polymorphism.png" style="padding:0; border:none"><img title="Polymorphism in Eclipse" src="images/polymorphism.png" alt="Polymorphism in Eclipse" /></a><br />
Figure 2.2.4: Statically verifying polymorphic types in Eclipse IDE using JML4/Disco
</p>
<h4 id="a2.2.5BlockLocalSupport">2.2.5 Block Local Support</h4>
<p>
Block locals are supported in JML4/Disco. This has proved problematic since Boogie requires all locals to be declared at the top of the procedure and has no support for inner blocks. Therefore, any unique variable names local to a block would end up being non-unique in a Boogie procedure. To deal with this, a <tt>RemoveLocal</tt> statement added to the Boogie AST during traversal of the Java AST whenever a block ends. Then, if during output, a <tt>RemoveLocal</tt> is traversed, the relevant local declaration is removed from the Boogie AST. This allows each variable to be unique during traversal. This design has a flaw, however, that destructively modifies the Boogie AST when <tt>toBuffer</tt> is called. This means that <tt>toBuffer</tt> cannot be called twice on a <tt>Procedure</tt> node. Ideally this solution should be refactored in the future to allow for multiple traversals without destroying the AST.
</p>
<h3 id="a2.3LimitationsoftheBoogieCompilerExtension">2.3 Limitations of the Boogie Compiler Extension</h3>
<p>
More limitations of the code coverage of the Java/JML languages can be found in the <a href="/trac/wiki/JavaCoverageTraceability" class="wiki">Java Coverage Traceability</a> document.
</p>
</div>
   </div>
   
    
    
  
  
   
  
  <script type="text/javascript">
   addHeadingLinks(document.getElementById("searchable"), "Link to this section");
  </script>
 
 
</div>

<script type="text/javascript">searchHighlight()</script>


</div>





 </body>
</html>

